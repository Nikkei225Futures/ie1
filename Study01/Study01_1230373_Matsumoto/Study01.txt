VScodeで書いているので、図？がずれている可能性があります。

Study01_1.java
工夫した点: コマンドライン引数の各々の文字列の長さを格納する配列を作って使用したことで、プログラムが簡潔になるようにした。

Study01_2.java
工夫した点:

1234*
123*1*
12*123*
1*12345*
*1234567*   ←中心
 *     *    ←ここは中心-1行目のコピー
  *   *     ←ここは中心-2行目のコピー
   * *      ←ここは中心-3行目のコピー
    *       ←ここは中心-4行目のコピー

各行の文字列として、配列に格納する。
*の前に来る空白の数と、*の後のひし形の内側の空白の数(各行)は
前者は、0行目が先頭だとすると、0行目は入力-1で、入力-2, 入力-3,...と0になるまで減り、
後者は、1行目から1, 3, 5, 7...と増えて、奇数列になっていることが分かった。
また、ひし形は入力をNとすると、N行目を中心に上下が対称になっている。
1.よって、最初に先頭の行から、N行目まで、前方に空白を入れて、その後に1つ目の*を付ける。
2.そのあと、1行目からN行目まで1つ目の*の後方に空白を入れて、その後2つ目の*を付ける。
これで上半分が完成したので、N+i行目はN-i行目をコピーして挿入する。こうすることで、ひし形を作ることが出来た。

Study01_3.java
工夫した点: 
まず、1000以下の素数の個数は168個であるから、168個の配列を作り、その中に1000以下の素数を全て入れた。
その次に、168個の素数の出現回数をカウントする配列を作成し、0で初期化する。
次に、与えられたNに対して、168個の素数の配列から小さい順に割り切れるかどうか判定し、割り切れる最小の素数を見つける。
その次に、出現回数をカウントする配列の同インデックスを1加算し出現回数をカウントする。
こうすることで、素数と出現回数を疑似的に表の様にできるので分かりやすく簡潔に書けた。

Study01_4.java
工夫した点: 
まず、ベースとなる日曜日,月曜日,火曜日,...,土曜日の文字列が入った配列を作成し、同じ物をもうひとつ作成する。
もし、コマンドライン引数が"mon"なら、曜日を格納する配列の先頭は"月曜日"となるようにベースの配列をもとに入れ替える。
その次に入力を受け、1月1日からの経過日数を7で割った余りを求めることで、余り=配列のインデックスとする事ができる。
こうすることで簡潔に書けるように工夫した。

Study01_5.java
工夫した点: 
まず、1000以下の素数の個数は168個であるから、168個の配列を作る。しかし、
while(配列の要素が0でない){
    出力
}
というようになっているので、第二引数に1000が入力された時、168個の全ての配列が埋まり、0が無くなる。
なので、終端の検出をするために168+1個の配列を用意する。
後は、AからBの範囲で素数かどうかの判定を行い、素数なら配列にその数を入れるという様にした。